
module mod_thrmdyn
use mod_precision
use mod_debug
implicit none
private
public :: THRMDYN_qd
public :: THRMDYN_cv
public :: THRMDYN_cp
public :: THRMDYN_rho
public :: THRMDYN_pre
public :: THRMDYN_ein
public :: THRMDYN_tem
public :: THRMDYN_th
public :: THRMDYN_eth
public :: THRMDYN_ent
public :: THRMDYN_rhoein
public :: THRMDYN_tempre
public :: THRMDYN_cv_ijk
public :: THRMDYN_qd_ijk
public :: THRMDYN_tempre_ijk
interface THRMDYN_qd
module procedure THRMDYN_qd_ijk
module procedure THRMDYN_qd_ijkl
end interface THRMDYN_qd
interface THRMDYN_cv
module procedure THRMDYN_cv_ijk
end interface THRMDYN_cv
interface THRMDYN_cp
module procedure THRMDYN_cp_ijk
end interface THRMDYN_cp
interface THRMDYN_rho
module procedure THRMDYN_rho_ijk
end interface THRMDYN_rho
interface THRMDYN_pre
module procedure THRMDYN_pre_ijk
end interface THRMDYN_pre
interface THRMDYN_ein
module procedure THRMDYN_ein_ijk
end interface THRMDYN_ein
interface THRMDYN_tem
module procedure THRMDYN_tem_ijk
end interface THRMDYN_tem
interface THRMDYN_th
module procedure THRMDYN_th_ijk
module procedure THRMDYN_th_ijkl
end interface THRMDYN_th
interface THRMDYN_eth
module procedure THRMDYN_eth_ijk
module procedure THRMDYN_eth_ijkl
end interface THRMDYN_eth
interface THRMDYN_ent
module procedure THRMDYN_ent_ijk
end interface THRMDYN_ent
interface THRMDYN_rhoein
module procedure THRMDYN_rhoein_ijkl
end interface THRMDYN_rhoein
interface THRMDYN_tempre
module procedure THRMDYN_tempre_ijk
module procedure THRMDYN_tempre_ijkl
end interface THRMDYN_tempre
contains
subroutine THRMDYN_qd_ijk( ijdim, kdim, q, qd     )
use mod_debug, only: nqmax, NQW_STR, NQW_END
implicit none
integer,  intent(in)  :: ijdim
integer,  intent(in)  :: kdim
real(RP), intent(in)  :: q (ijdim,kdim,nqmax) 
real(RP), intent(out) :: qd(ijdim,kdim)       
integer :: ij, k, nq
@domainDependant{attribute(autoDom, present)}
q, qd
@end domainDependant
@parallelRegion{domName(ij,k), domSize(ijdim,kdim)}
qd(ij,k) = 1.0_RP
do nq = NQW_STR, NQW_END
qd(ij,k) = qd(ij,k) - q(ij,k,nq)
enddo
@end parallelRegion
return
end subroutine THRMDYN_qd_ijk
subroutine THRMDYN_qd_ijkl( ijdim, kdim, ldim, q, qd     )
implicit none
integer,  intent(in)  :: ijdim
integer,  intent(in)  :: kdim
integer,  intent(in)  :: ldim
real(RP), intent(in)  :: q (ijdim,kdim,ldim,nqmax) 
real(RP), intent(out) :: qd(ijdim,kdim,ldim)       
integer :: ij, k, l, nq
!$omp parallel default(none),private(ij,k,l,nq), shared(ijdim,kdim,ldim,NQW_STR,NQW_END,qd,q)
!$omp do
do l  = 1, ldim
do k  = 1, kdim
do ij = 1, ijdim
qd(ij,k,l) = 1.0_RP
enddo
enddo
enddo
!$omp end do
do nq = NQW_STR, NQW_END
!$omp do
do l  = 1, ldim
do k  = 1, kdim
do ij = 1, ijdim
qd(ij,k,l) = qd(ij,k,l) - q(ij,k,l,nq)
enddo
enddo
enddo
!$omp end do
enddo
!$omp end parallel
return
end subroutine THRMDYN_qd_ijkl
subroutine THRMDYN_cv_ijk( ijdim, kdim, qd, q, cv     )
use mod_debug, only: nqmax, NQW_STR, NQW_END, CVW
implicit none
integer,  intent(in)  :: ijdim
integer,  intent(in)  :: kdim
real(RP), intent(in)  :: qd(ijdim,kdim)       
real(RP), intent(in)  :: q (ijdim,kdim,nqmax) 
real(RP), intent(out) :: cv(ijdim,kdim)       
real(RP) :: CVdry
integer  :: ij, k, nq
@domainDependant{attribute(autoDom, present)}
qd, q, cv, CVW
@end domainDependant
CVdry = CONST_CVdry
@parallelRegion{domName(ij,k), domSize(ijdim,kdim)}
cv(ij,k) = qd(ij,k) * CVdry
do nq = NQW_STR, NQW_END
cv(ij,k) = cv(ij,k) + q(ij,k,nq) * CVW(nq)
enddo
@end parallelRegion
return
end subroutine THRMDYN_cv_ijk
subroutine THRMDYN_cp_ijk( ijdim, kdim, qd, q, cp     )
implicit none
integer,  intent(in)  :: ijdim
integer,  intent(in)  :: kdim
real(RP), intent(in)  :: qd(ijdim,kdim)       
real(RP), intent(in)  :: q (ijdim,kdim,nqmax) 
real(RP), intent(out) :: cp(ijdim,kdim)       
real(RP) :: CPdry
integer  :: ij, k, nq
CPdry = CONST_CPdry
!$omp parallel default(none),private(ij,k,nq), shared(ijdim,kdim,NQW_STR,NQW_END,cp,qd,q,CPW,CPdry)
!$omp do
do k  = 1, kdim
do ij = 1, ijdim
cp(ij,k) = qd(ij,k) * CPdry
enddo
enddo
!$omp end do
do nq = NQW_STR, NQW_END
!$omp do
do k  = 1, kdim
do ij = 1, ijdim
cp(ij,k) = cp(ij,k) + q(ij,k,nq) * CPW(nq)
enddo
enddo
!$omp end do
enddo
!$omp end parallel
return
end subroutine THRMDYN_cp_ijk
subroutine THRMDYN_rho_ijk( ijdim, kdim, tem, pre, qd, q, rho    )
implicit none
integer,  intent(in)  :: ijdim
integer,  intent(in)  :: kdim
real(RP), intent(in)  :: tem(ijdim,kdim)       
real(RP), intent(in)  :: pre(ijdim,kdim)       
real(RP), intent(in)  :: qd (ijdim,kdim)       
real(RP), intent(in)  :: q  (ijdim,kdim,nqmax) 
real(RP), intent(out) :: rho(ijdim,kdim)       
real(RP) :: Rdry, Rvap
integer  :: ij, k
Rdry = CONST_Rdry
Rvap = CONST_Rvap
!$acc kernels pcopy(rho) pcopyin(pre,tem,qd,q) async(0)
!$omp parallel do default(none),private(ij,k), shared(ijdim,kdim,rho,pre,tem,qd,q,Rdry,Rvap,I_QV)
do k  = 1, kdim
do ij = 1, ijdim
rho(ij,k) = pre(ij,k) / ( ( qd(ij,k)*Rdry + q(ij,k,I_QV)*Rvap ) * tem(ij,k) )
enddo
enddo
!$omp end parallel do
!$acc end kernels
return
end subroutine THRMDYN_rho_ijk
subroutine THRMDYN_pre_ijk( ijdim, kdim, rho, tem, qd, q, pre    )
implicit none
integer,  intent(in)  :: ijdim
integer,  intent(in)  :: kdim
real(RP), intent(in)  :: rho(ijdim,kdim)       
real(RP), intent(in)  :: tem(ijdim,kdim)       
real(RP), intent(in)  :: qd (ijdim,kdim)       
real(RP), intent(in)  :: q  (ijdim,kdim,nqmax) 
real(RP), intent(out) :: pre(ijdim,kdim)       
real(RP) :: Rdry, Rvap
integer  :: ij, k
Rdry = CONST_Rdry
Rvap = CONST_Rvap
!$acc kernels pcopy(pre) pcopyin(rho,tem,qd,q) async(0)
!$omp parallel do default(none),private(ij,k), shared(ijdim,kdim,pre,rho,tem,qd,q,Rdry,Rvap,I_QV)
do k  = 1, kdim
do ij = 1, ijdim
pre(ij,k) = rho(ij,k) * tem(ij,k) * ( qd(ij,k)*Rdry + q(ij,k,I_QV)*Rvap )
enddo
enddo
!$omp end parallel do
!$acc end kernels
return
end subroutine THRMDYN_pre_ijk
subroutine THRMDYN_ein_ijk( ijdim, kdim, tem, qd, q, ein    )
implicit none
integer,  intent(in)  :: ijdim
integer,  intent(in)  :: kdim
real(RP), intent(in)  :: tem(ijdim,kdim)       
real(RP), intent(in)  :: qd (ijdim,kdim)       
real(RP), intent(in)  :: q  (ijdim,kdim,nqmax) 
real(RP), intent(out) :: ein(ijdim,kdim)       
real(RP) :: cv(ijdim,kdim)
real(RP) :: CVdry
integer :: ij, k, nq
CVdry = CONST_CVdry
!$omp parallel default(none),private(ij,k,nq), shared(ijdim,kdim,NQW_STR,NQW_END,ein,tem,cv,qd,q,CVW,CVdry)
!$omp do
do k  = 1, kdim
do ij = 1, ijdim
cv(ij,k) = qd(ij,k) * CVdry
enddo
enddo
!$omp end do
do nq = NQW_STR, NQW_END
!$omp do
do k  = 1, kdim
do ij = 1, ijdim
cv(ij,k) = cv(ij,k) + q(ij,k,nq) * CVW(nq)
enddo
enddo
!$omp end do
enddo
!$omp do
do k  = 1, kdim
do ij = 1, ijdim
ein(ij,k) = tem(ij,k) * cv(ij,k)
enddo
enddo
!$omp end do
!$omp end parallel
return
end subroutine THRMDYN_ein_ijk
subroutine THRMDYN_tem_ijk( ijdim, kdim, ein, qd, q, tem    )
implicit none
integer,  intent(in)  :: ijdim
integer,  intent(in)  :: kdim
real(RP), intent(in)  :: ein(ijdim,kdim)       
real(RP), intent(in)  :: qd (ijdim,kdim)       
real(RP), intent(in)  :: q  (ijdim,kdim,nqmax) 
real(RP), intent(out) :: tem(ijdim,kdim)       
real(RP) :: cv(ijdim,kdim)
real(RP) :: CVdry
integer :: ij, k, nq
CVdry = CONST_CVdry
!$omp parallel default(none),private(ij,k,nq), shared(ijdim,kdim,NQW_STR,NQW_END,tem,ein,cv,qd,q,CVW,CVdry)
!$omp do
do k  = 1, kdim
do ij = 1, ijdim
cv(ij,k) = qd(ij,k) * CVdry
enddo
enddo
!$omp end do
do nq = NQW_STR, NQW_END
!$omp do
do k  = 1, kdim
do ij = 1, ijdim
cv(ij,k) = cv(ij,k) + q(ij,k,nq) * CVW(nq)
enddo
enddo
!$omp end do
enddo
!$omp do
do k  = 1, kdim
do ij = 1, ijdim
tem(ij,k) = ein(ij,k) / cv(ij,k)
enddo
enddo
!$omp end do
!$omp end parallel
return
end subroutine THRMDYN_tem_ijk
subroutine THRMDYN_th_ijk( ijdim, kdim, tem, pre, th     )
implicit none
integer,  intent(in)  :: ijdim
integer,  intent(in)  :: kdim
real(RP), intent(in)  :: tem(ijdim,kdim) 
real(RP), intent(in)  :: pre(ijdim,kdim) 
real(RP), intent(out) :: th (ijdim,kdim) 
real(RP) :: RovCP, PRE00
integer  :: ij, k
RovCP = CONST_Rdry / CONST_CPdry
PRE00 = CONST_PRE00
!$acc kernels pcopy(th) pcopyin(tem,pre) async(0)
!$omp parallel do default(none),private(ij,k), shared(ijdim,kdim,th,tem,pre,RovCP,PRE00)
do k  = 1, kdim
do ij = 1, ijdim
th(ij,k) = tem(ij,k) * ( PRE00 / pre(ij,k) )**RovCP
enddo
enddo
!$omp end parallel do
!$acc end kernels
return
end subroutine THRMDYN_th_ijk
subroutine THRMDYN_th_ijkl( ijdim, kdim, ldim, tem, pre, th     )
implicit none
integer,  intent(in)  :: ijdim
integer,  intent(in)  :: kdim
integer,  intent(in)  :: ldim
real(RP), intent(in)  :: tem(ijdim,kdim,ldim) 
real(RP), intent(in)  :: pre(ijdim,kdim,ldim) 
real(RP), intent(out) :: th (ijdim,kdim,ldim) 
real(RP) :: RovCP, PRE00
integer  :: ij, k, l
RovCP = CONST_Rdry / CONST_CPdry
PRE00 = CONST_PRE00
!$acc kernels pcopy(th) pcopyin(tem,pre) async(0)
!$omp parallel do default(none),private(ij,k,l), shared(ijdim,kdim,ldim,th,tem,pre,RovCP,PRE00)
do l  = 1, ldim
do k  = 1, kdim
do ij = 1, ijdim
th(ij,k,l) = tem(ij,k,l) * ( PRE00 / pre(ij,k,l) )**RovCP
enddo
enddo
enddo
!$omp end parallel do
!$acc end kernels
return
end subroutine THRMDYN_th_ijkl
subroutine THRMDYN_eth_ijk( ijdim, kdim, ein, pre, rho, eth    )
implicit none
integer,  intent(in)  :: ijdim
integer,  intent(in)  :: kdim
real(RP), intent(in)  :: ein(ijdim,kdim) 
real(RP), intent(in)  :: pre(ijdim,kdim) 
real(RP), intent(in)  :: rho(ijdim,kdim) 
real(RP), intent(out) :: eth(ijdim,kdim) 
integer :: ij, k
!$acc kernels pcopy(eth) pcopyin(ein,pre,rho) async(0)
!$omp parallel do default(none),private(ij,k), shared(ijdim,kdim,eth,ein,pre,rho)
do k  = 1, kdim
do ij = 1, ijdim
eth(ij,k) = ein(ij,k) + pre(ij,k) / rho(ij,k)
enddo
enddo
!$omp end parallel do
!$acc end kernels
return
end subroutine THRMDYN_eth_ijk
subroutine THRMDYN_eth_ijkl( ijdim, kdim, ldim, ein, pre, rho, eth    )
implicit none
integer,  intent(in)  :: ijdim
integer,  intent(in)  :: kdim
integer,  intent(in)  :: ldim
real(RP), intent(in)  :: ein(ijdim,kdim,ldim) 
real(RP), intent(in)  :: pre(ijdim,kdim,ldim) 
real(RP), intent(in)  :: rho(ijdim,kdim,ldim) 
real(RP), intent(out) :: eth(ijdim,kdim,ldim) 
integer :: ij, k, l
!$acc kernels pcopy(eth) pcopyin(ein,pre,rho) async(0)
!$omp parallel do default(none),private(ij,k,l), shared(ijdim,kdim,ldim,eth,ein,pre,rho)
do l  = 1, ldim
do k  = 1, kdim
do ij = 1, ijdim
eth(ij,k,l) = ein(ij,k,l) + pre(ij,k,l) / rho(ij,k,l)
enddo
enddo
enddo
!$omp end parallel do
!$acc end kernels
return
end subroutine THRMDYN_eth_ijkl
subroutine THRMDYN_ent_ijk( ijdim, kdim, tem, pre, qd, q, ent    )
implicit none
integer,  intent(in)  :: ijdim
integer,  intent(in)  :: kdim
real(RP), intent(in)  :: tem(ijdim,kdim)
real(RP), intent(in)  :: pre(ijdim,kdim)
real(RP), intent(in)  :: qd (ijdim,kdim)
real(RP), intent(in)  :: q  (ijdim,kdim,nqmax)
real(RP), intent(out) :: ent(ijdim,kdim)
real(RP) :: Pdry
real(RP) :: Pvap
real(RP) :: LH(nqmax)
real(RP) :: CPdry, Rdry, Rvap, TEM00, PRE00, PSAT0, EPSvap
real(RP), parameter :: EPS = 1.E-10_RP
integer  :: ij, k, nq
CPdry  = CONST_CPdry
Rdry   = CONST_Rdry
Rvap   = CONST_Rvap
TEM00  = CONST_TEM00
PRE00  = CONST_PRE00
PSAT0  = CONST_PSAT0
EPSvap = CONST_EPSvap
do nq = NQW_STR, NQW_END
if ( nq == I_QV ) then
LH(nq) =  CONST_LHV / TEM00
elseif( nq == I_QI .OR. nq == I_QS .OR. nq == I_QG ) then
LH(nq) = -CONST_LHF / TEM00
else
LH(nq) = 0.0_RP
endif
enddo
!$omp parallel default(none),private(ij,k,Pdry,Pvap), shared(ijdim,kdim,nq,NQW_STR,NQW_END,ent,tem,pre,qd,q, LH,CVW,CPdry,Rdry,Rvap,TEM00,PRE00,PSAT0,EPSvap,I_QV)
!$acc kernels pcopy(ent) pcopyin(tem,pre,qd,q) async(0)
!$omp do
do k  = 1, kdim
do ij = 1, ijdim
Pdry = max( pre(ij,k) * EPSvap*qd(ij,k) / ( EPSvap*qd(ij,k) + q(ij,k,I_QV) ), EPS )
Pvap = max( pre(ij,k) * q(ij,k,I_QV)    / ( EPSvap*qd(ij,k) + q(ij,k,I_QV) ), EPS )
ent(ij,k) = qd(ij,k)      * CPdry * log( tem(ij,k)/TEM00 ) - qd(ij,k)      * Rdry  * log( Pdry     /PRE00 ) - q (ij,k,I_QV) * Rvap  * log( Pvap     /PSAT0 )
enddo
enddo
!$omp end do
!$acc end kernels
do nq = NQW_STR, NQW_END
!$omp do
do k  = 1, kdim
do ij = 1, ijdim
ent(ij,k) = ent(ij,k) + q(ij,k,nq) * CVW(nq) * log( tem(ij,k)/TEM00 ) + q(ij,k,nq) * LH (nq) / TEM00
enddo
enddo
!$omp end do
enddo
!$omp end parallel
return
end subroutine THRMDYN_ent_ijk
subroutine THRMDYN_rhoein_ijkl( ijdim, kdim, ldim, tem, pre, q, rho, ein    )
implicit none
integer,  intent(in)  :: ijdim
integer,  intent(in)  :: kdim
integer,  intent(in)  :: ldim
real(RP), intent(in)  :: tem(ijdim,kdim,ldim)       
real(RP), intent(in)  :: pre(ijdim,kdim,ldim)       
real(RP), intent(in)  :: q  (ijdim,kdim,ldim,nqmax) 
real(RP), intent(out) :: rho(ijdim,kdim,ldim)       
real(RP), intent(out) :: ein(ijdim,kdim,ldim)       
real(RP) :: cv(ijdim,kdim,ldim)
real(RP) :: qd(ijdim,kdim,ldim)
real(RP) :: CVdry, Rdry, Rvap
integer  :: ij, k, l, nq
CVdry = CONST_CVdry
Rdry  = CONST_Rdry
Rvap  = CONST_Rvap
!$omp parallel default(none),private(ij,k,l,nq), shared(ijdim,kdim,ldim,NQW_STR,NQW_END,rho,ein,tem,pre,q,cv,qd,CVW,CVdry,Rdry,Rvap,I_QV)
!$omp do
do l  = 1, ldim
do k  = 1, kdim
do ij = 1, ijdim
cv(ij,k,l) = 0.0_RP
qd(ij,k,l) = 1.0_RP
enddo
enddo
enddo
!$omp end do
do nq = NQW_STR, NQW_END
!$omp do
do l  = 1, ldim
do k  = 1, kdim
do ij = 1, ijdim
cv(ij,k,l) = cv(ij,k,l) + q(ij,k,l,nq) * CVW(nq)
qd(ij,k,l) = qd(ij,k,l) - q(ij,k,l,nq)
enddo
enddo
enddo
!$omp end do
enddo
!$omp do
do l  = 1, ldim
do k  = 1, kdim
do ij = 1, ijdim
cv(ij,k,l) = cv(ij,k,l) + qd(ij,k,l) * CVdry
rho(ij,k,l) = pre(ij,k,l) / tem(ij,k,l) / ( qd(ij,k,l)*Rdry + q(ij,k,l,I_QV)*Rvap )
ein(ij,k,l) = tem(ij,k,l) * cv(ij,k,l)
enddo
enddo
enddo
!$omp end do
!$omp end parallel
return
end subroutine THRMDYN_rhoein_ijkl
subroutine THRMDYN_tempre_ijk( ijdim, kdim, ein, rho, q, tem, pre    )
use mod_debug, only: CONST_Rdry, CONST_Rvap, CONST_CVdry, nqmax, NQW_STR, NQW_END, I_QV, CVW
implicit none
integer,  intent(in)  :: ijdim
integer,  intent(in)  :: kdim
real(RP), intent(in)  :: ein(ijdim,kdim)       
real(RP), intent(in)  :: rho(ijdim,kdim)       
real(RP), intent(in)  :: q  (ijdim,kdim,nqmax) 
real(RP), intent(out) :: tem(ijdim,kdim)       
real(RP), intent(out) :: pre(ijdim,kdim)       
real(RP) :: cv(ijdim,kdim)
real(RP) :: qd(ijdim,kdim)
real(RP) :: CVdry, Rdry, Rvap
integer  :: ij, k, nq
@domainDependant{attribute(present, autoDom)}
ein, rho, q, tem, pre, cv, qd, CVW
@end domainDependant
CVdry = CONST_CVdry
Rdry  = CONST_Rdry
Rvap  = CONST_Rvap
@parallelRegion{domName(ij,k), domSize(ijdim,kdim)}
cv(ij,k) = 0.0_RP
qd(ij,k) = 1.0_RP
@end parallelRegion
do nq = NQW_STR, NQW_END
@parallelRegion{domName(ij,k), domSize(ijdim,kdim)}
cv(ij,k) = cv(ij,k) + q(ij,k,nq) * CVW(nq)
qd(ij,k) = qd(ij,k) - q(ij,k,nq)
@end parallelRegion
enddo
@parallelRegion{domName(ij,k), domSize(ijdim,kdim)}
cv (ij,k) = cv (ij,k) + qd (ij,k) * CVdry
tem(ij,k) = ein(ij,k) / cv (ij,k)
pre(ij,k) = rho(ij,k) * tem(ij,k) * ( qd(ij,k)*Rdry + q(ij,k,I_QV)*Rvap )
@end parallelRegion
return
end subroutine THRMDYN_tempre_ijk
subroutine THRMDYN_tempre_ijkl( ijdim, kdim, ldim, ein, rho, q, tem, pre    )
implicit none
integer,  intent(in)  :: ijdim
integer,  intent(in)  :: kdim
integer,  intent(in)  :: ldim
real(RP), intent(in)  :: ein(ijdim,kdim,ldim)       
real(RP), intent(in)  :: rho(ijdim,kdim,ldim)       
real(RP), intent(in)  :: q  (ijdim,kdim,ldim,nqmax) 
real(RP), intent(out) :: tem(ijdim,kdim,ldim)       
real(RP), intent(out) :: pre(ijdim,kdim,ldim)       
real(RP) :: cv(ijdim,kdim,ldim)
real(RP) :: qd(ijdim,kdim,ldim)
real(RP) :: CVdry, Rdry, Rvap
integer  :: ij, k, l, nq
CVdry = CONST_CVdry
Rdry  = CONST_Rdry
Rvap  = CONST_Rvap
!$omp parallel default(none),private(ij,k,l,nq), shared(ijdim,kdim,ldim,NQW_STR,NQW_END,tem,pre,ein,rho,q,cv,qd,CVW,CVdry,Rdry,Rvap,I_QV)
!$omp do
do l  = 1, ldim
do k  = 1, kdim
do ij = 1, ijdim
cv(ij,k,l) = 0.0_RP
qd(ij,k,l) = 1.0_RP
enddo
enddo
enddo
!$omp end do
do nq = NQW_STR, NQW_END
!$omp do
do l  = 1, ldim
do k  = 1, kdim
do ij = 1, ijdim
cv(ij,k,l) = cv(ij,k,l) + q(ij,k,l,nq) * CVW(nq)
qd(ij,k,l) = qd(ij,k,l) - q(ij,k,l,nq)
enddo
enddo
enddo
!$omp end do
enddo
!$omp do
do l  = 1, ldim
do k  = 1, kdim
do ij = 1, ijdim
cv (ij,k,l) = cv (ij,k,l) + qd (ij,k,l) * CVdry
tem(ij,k,l) = ein(ij,k,l) / cv (ij,k,l)
pre(ij,k,l) = rho(ij,k,l) * tem(ij,k,l) * ( qd(ij,k,l)*Rdry + q(ij,k,l,I_QV)*Rvap )
enddo
enddo
enddo
!$omp end do
!$omp end parallel
return
end subroutine THRMDYN_tempre_ijkl
end module mod_thrmdyn

